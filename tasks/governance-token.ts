import { task } from "hardhat/config";
import { TaskArguments } from "hardhat/types";
import { exit } from "process";

import {
  OrigamiGovernanceToken,
  OrigamiGovernanceTokenFactory,
  OrigamiGovernanceTokenFactory__factory,
  OrigamiGovernanceToken__factory,
} from "../src/types";
import { timeStamp, verboseLog } from "./utils";

task("governance-token:query", "WIP query task for data about the OrigamiGovernanceToken contract")
  .addParam("contractAddress", "address of the OrigamiGovernanceTokenFactory")
  .setAction(async (args: TaskArguments, { ethers }) => {
    const OGT__factory: OrigamiGovernanceToken__factory = await ethers.getContractFactory("OrigamiGovernanceToken");
    const OGT: OrigamiGovernanceToken = await OGT__factory.attach(args.contractAddress);

    console.log("status:", {
      name: await OGT.name(),
      symbol: await OGT.symbol(),
      supplyCap: await OGT.cap(),
      paused: await OGT.paused(),
      minterRole: await OGT.MINTER_ROLE(),
      pauserRole: await OGT.PAUSER_ROLE(),
      burnable: await OGT.burnable(),
      transferrable: await OGT.transferrable(),
    });
  });

task(
  "governance-token:deploy",
  "DO NOT USE! CLONE INSTEAD WHENEVER POSSIBLE!! Does a direct deploy of the OrigamiGovernanceToken contract",
)
  .addFlag("verboseOutput", "Adds verbose output to the deploy task")
  .addFlag("confirmDeploy", "Confirms that, against all advice, you still want to deploy instead of clone.")
  .addParam("admin", "address of the admin for the OrigamiGovernanceToken generated by the factory")
  .addParam("name", "name for the OrigamiGovernanceToken generated by the factory")
  .addParam("symbol", "symbol for the OrigamiGovernanceToken generated by the factory")
  .addParam("supplyCap", "supplyCap for the OrigamiGovernanceToken generated by the factory")
  .setAction(async (args: TaskArguments, { ethers, network, upgrades }) => {
    if (!args.confirmDeploy) {
      console.log("It is STRONGLY recommended that you clone instead of deploy.");
      console.log("   -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
      console.log("If you are certain that you still want to deploy, run this task again with --confirm-deploy\n");
      exit(1);
    }

    console.log(timeStamp(), `Deploying OrigamiGovernanceToken on ${network.name}`);

    const OGT__factory = await ethers.getContractFactory("OrigamiGovernanceToken");
    verboseLog(args, "OrigamiGovernanceToken instantiated");
    const OGT: OrigamiGovernanceToken = <OrigamiGovernanceToken>(
      await upgrades.deployProxy(OGT__factory, [args.admin, args.name, args.symbol, args.supplyCap])
    );
    verboseLog(args, "OrigamiGovernanceToken deploy initiated");
    await OGT.deployed();

    verboseLog(args, "OrigamiGovernanceToken deploy completed");
    verboseLog(args, "OrigamiGovernanceToken transaction", OGT.deployTransaction.hash);
    verboseLog(
      args,
      "OrigamiGovernanceToken transaction receipt",
      await (
        await ethers.provider.getTransactionReceipt(OGT.deployTransaction.hash)
      ).transactionHash,
    );
    console.log(timeStamp(), `OrigamiGovernanceToken deployed at ${OGT.address}`);

    if (!["hardhat", "localhost"].includes(network.name)) {
      console.log(timeStamp(), "Waiting for >= 5 OrigamiGovernanceToken deployment confirmations");
      await OGT.deployTransaction.wait(5);
    }
    console.log(timeStamp(), "Finished deploy!");
    console.log(
      `\nWhen ready, verify with: \n\nyarn hardhat post-verify --network ${network.name} --contract-address ${OGT.address}`,
    );
  });

task("governance-token:clone", "Clones a new governance token from the factory contract")
  .addParam("factoryAddress", "address of the OrigamiGovernanceTokenFactory")
  .addParam("admin", "address of the admin for the OrigamiGovernanceToken generated by the factory")
  .addParam("name", "name for the OrigamiGovernanceToken generated by the factory")
  .addParam("symbol", "symbol for the OrigamiGovernanceToken generated by the factory")
  .addParam("supplyCap", "supplyCap for the OrigamiGovernanceToken generated by the factory")
  .setAction(async (args: TaskArguments, { ethers }) => {
    const OGTF__factory: OrigamiGovernanceTokenFactory__factory = await ethers.getContractFactory(
      "OrigamiGovernanceTokenFactory",
    );
    const OGTF: OrigamiGovernanceTokenFactory = await OGTF__factory.attach(args.factoryAddress);

    console.log("attached to OrigamiGovernanceTokenFactory");
    // console.log({ args });

    const tx = await OGTF.createOrigamiGovernanceToken(args.admin, args.name, args.symbol, args.supplyCap);
    await tx.wait(5);

    console.log("OrigamiGovernanceToken created");

    console.log({ tx });
    // console.log(`OrigamiGovernanceToken deployed at ${tx.to}`);
  });

task("governance-token:upgrade", "Upgrades the OrigamiGovernanceToken contract")
  .addParam("proxyAddress", "address of the OrigamiGovernanceToken proxy")
  .setAction(async (args: TaskArguments, { ethers, network, upgrades }) => {
    console.log(timeStamp(), `Upgrading OrigamiGovernanceToken on ${network.name}`);
    const OGT__factory = await ethers.getContractFactory("OrigamiGovernanceToken");
    const OGT = await upgrades.upgradeProxy(args.proxyAddress, OGT__factory);
    console.log(timeStamp(), `OrigamiGovernanceToken upgraded at ${OGT.address}`);
  });

task("governance-token:upgrade-forced", "Upgrades the OrigamiGovernanceToken contract")
  .addParam("proxyAddress", "address of the OrigamiGovernanceToken proxy")
  .addFlag("verboseOutput", "Adds verbose output to the deploy task")
  .setAction(async (args: TaskArguments, { ethers, network, upgrades }) => {
    console.log(timeStamp(), `Upgrading OrigamiGovernanceToken on ${network.name}`);
    const OGT__factory = await ethers.getContractFactory("OrigamiGovernanceToken");
    verboseLog(args, "forcing the import of the previously deployed OrigamiGovernanceToken for upgrade");
    await upgrades.forceImport(args.proxyAddress, OGT__factory);
    const OGT = await upgrades.upgradeProxy(args.proxyAddress, OGT__factory);
    console.log(timeStamp(), `OrigamiGovernanceToken upgraded at ${OGT.address}`);
  });

task("governance-token:mint", "mint tokens (specify quantities in wei)")
  .addParam("contractAddress", "address of the OrigamiGovernanceToken")
  .addParam("recipientAddress", "address of the recipient of the OrigameGovernanceToken")
  .addParam("amount", "integer value in wei")
  .setAction(async (args: TaskArguments, { ethers }) => {
    const OGT__factory: OrigamiGovernanceToken__factory = await ethers.getContractFactory("OrigamiGovernanceToken");
    const OGT: OrigamiGovernanceToken = await OGT__factory.attach(args.contractAddress);

    await OGT.mint(args.recipientAddress, args.amount);
  });
